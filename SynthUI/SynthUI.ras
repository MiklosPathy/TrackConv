program SynthUI;

@use "SimpleCharFunctions"
@use "YM2151"
@use "X16Mouse"


var
    //WidgetMap: array[4800] of byte;

	ymoctavenote:byte;
	key : byte;
	note : byte;
	octave:byte;
	transpose:byte=3;

	mouseXchpos: byte;
	mouseYchpos: byte;
	
	spres:byte;
	
	mouseXchposAtClick: byte;
	mouseYchposAtClick: byte;
	mouseClicked:byte;
	
    @define ButtonCount 2
	buttonposX:array[@ButtonCount] of byte = (10,15);
	buttonposY:array[@ButtonCount] of byte = (10,10);
	buttonWidth:array[@ButtonCount] of byte = (3,3);
	buttonHeight:array[@ButtonCount] of byte = (3,3);
	buttonColor:array[@ButtonCount] of byte = (8,9);
	buttonLabel:array[@ButtonCount] of byte = (45,43);
	
	@define Vertical 0
	@define Horizontal 1
	@define SliderCount 2
	sliderposX:array[@SliderCount] of byte = (10,10);
	sliderposY:array[@SliderCount] of byte = (20,50);
	sliderLength:array[@SliderCount] of byte = (8,60);
	sliderColor:array[@SliderCount] of byte = (4,5);
	sliderValue:array[@SliderCount] of byte = (0,5);
	sliderMax:array[@SliderCount] of byte = (7,10);
	sliderMode:array[@SliderCount] of byte = (@Vertical,@Horizontal);
	clickedSlider:byte=$FF;


procedure getin();
	begin
	asm("
		jsr $FFE4
		sta key
	");
	end;

procedure key2note();
	begin
	note:=$FF;
    case key of
	    $5A: begin octave:=0;note:=0; end;
	    $53: begin octave:=0;note:=1; end;
	    $58: begin octave:=0;note:=2; end;
	    $44: begin octave:=0;note:=3; end; 
	    $43: begin octave:=0;note:=4; end;
	    $56: begin octave:=0;note:=5; end;
	    $47: begin octave:=0;note:=6; end;
	    $42: begin octave:=0;note:=7; end;
		$48: begin octave:=0;note:=8; end;
		$4E: begin octave:=0;note:=9; end;
		$4A: begin octave:=0;note:=10; end;
		$4D: begin octave:=0;note:=11; end;
		$2C: begin octave:=1;note:=0; end;
		$4C: begin octave:=1;note:=1; end;
		$2E: begin octave:=1;note:=2; end;
		$3B: begin octave:=1;note:=3; end;
		$2F: begin octave:=1;note:=4; end;
		$51: begin octave:=1;note:=0; end;
		$32: begin octave:=1;note:=1; end;
		$57: begin octave:=1;note:=2; end;
		$33: begin octave:=1;note:=3; end;
		$45: begin octave:=1;note:=4; end;
		$52: begin octave:=1;note:=5; end;
		$35: begin octave:=1;note:=6; end;
		$54: begin octave:=1;note:=7; end;
		$36: begin octave:=1;note:=8; end;
		$59: begin octave:=1;note:=9; end;
		$37: begin octave:=1;note:=10; end;
		$55: begin octave:=1;note:=11; end;
		$49: begin octave:=2;note:=0; end;
		$39: begin octave:=2;note:=1; end;
		$4F: begin octave:=2;note:=2; end;
		$30: begin octave:=2;note:=3; end;
		$50: begin octave:=2;note:=4; end;
		$5B: begin octave:=2;note:=5; end;
		$3D: begin octave:=2;note:=6; end;
		$5D: begin octave:=2;note:=7; end;
	    end;
	end;

procedure toYMoctavenote();
	begin
	octave:=octave+transpose;  //Transpose
	if (note=0 and octave>0) then dec(octave);  //YMidiotizm
	ymoctavenote:=(YM2151::Normal2YMNote[note]&$F)|(octave<<4);
	end;

procedure handlebuttonclick();
	var i,mx2,my2,clickedButton:byte;
	begin
	i:=0;
	clickedButton:=$FF;
	while (i<@ButtonCount and clickedButton=$FF) do
		begin;
		mx2:=buttonposX[i]+buttonWidth[i];
		my2:=buttonposY[i]+buttonHeight[i];
		if (mouseXchposAtClick>=buttonposX[i] and mouseXchposAtClick<=mx2) then  //Ouch... Only 2 parametern in and in if??? 
			if (mouseYchposAtClick>=buttonposY[i] and mouseYchposAtClick<=my2) then clickedButton:=i;
		inc(i);
		end;

	case clickedButton of
		0: dec(transpose);
		1: inc(transpose);
		end;

	end;

procedure calcspres(splen,spval,spmax,sppos:byte);
	var temp:integer;
	begin
	temp:=splen*spval/spmax;
	spres:=temp+sppos;
	end;

procedure drawSlider(slid:byte);
	var i:byte;
	begin
	case sliderMode[slid] of
		@Vertical:
			begin	
			for i:=sliderposY[slid] to sliderposY[slid]+sliderLength[slid] do
				SCF::DrawChar(sliderposX[slid],i,$5D,sliderColor[slid]);
			SCF::DrawChar(sliderposX[slid],sliderposY[slid]+sliderValue[slid],$5B,sliderColor[slid]);
			end;
		@Horizontal:
			begin
			for i:=sliderposX[slid] to sliderposX[slid]+sliderLength[slid] do
				SCF::DrawChar(i,sliderposY[slid],$43,sliderColor[slid]);
				
			calcspres(sliderLength[slid],sliderValue[slid],sliderMax[slid],sliderposX[slid]);
			SCF::DrawChar(spres,sliderposY[slid],$5B,sliderColor[slid]);
			end;
		end;
	end;

procedure calcslvalue(mousepos,splen,spmax,sppos:byte);
	var temp,relpos:integer;
		rpb:byte;

	begin
	temp:=0;
	SCF::DrawHexByte(16,54,mousepos,1);
	SCF::DrawHexByte(22,54,sppos,1);
	SCF::DrawHexByte(16,55,splen,1);
	SCF::DrawHexByte(22,55,spmax,1);
	rpb:=splen/spmax/2;
	rpb:=mousepos-sppos+rpb;
	relpos:=rpb;
	SCF::DrawHexInt(16,52,relpos,1);
	temp:=relpos*spmax;
	SCF::DrawHexInt(22,52,temp,1);
	temp:=temp/splen;
	SCF::DrawHexInt(28,52,temp,1);
	spres:=temp;	
	end;

procedure calcSliderpos(slid:byte);
	begin
	case sliderMode[slid] of
		@Vertical:
			begin
			sliderValue[slid]:=mouseYchpos-sliderposY[slid];
			end;
		@Horizontal:
			begin	
			calcslvalue(mouseXchpos,sliderLength[slid],sliderMax[slid],sliderposX[slid]);	
			//sliderValue[slid]:=mouseXchpos-sliderposX[slid];
			sliderValue[slid]:=spres;
			end;
		end;						
	end;

procedure handlesliderclick();
	var i,mx2,my2:byte;
	begin

	if (mouseClicked=1 and clickedSlider<>$FF) then
		case sliderMode[clickedSlider] of
			@Vertical:
				begin
				my2:=sliderposY[clickedSlider]+sliderLength[clickedSlider]-1;
				if (mouseYchpos>=sliderposY[clickedSlider] and mouseYchpos<=my2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			@Horizontal:
				begin
				mx2:=sliderposX[clickedSlider]+sliderLength[clickedSlider]-1;
				if (mouseXchpos>=sliderposX[clickedSlider] and mouseXchpos<=mx2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			end
	else
		begin
		i:=0;
		clickedSlider:=$FF;

		while (i<@SliderCount and clickedSlider=$FF) do
			begin;
			case sliderMode[i] of
				@Vertical:
					begin			
					my2:=sliderposY[i]+sliderLength[i]-1;
					if (mouseXchpos=sliderposX[i]) then
						begin
						if (mouseYchpos>=sliderposY[i] and mouseYchpos<=my2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;
				@Horizontal:
					begin
					mx2:=sliderposX[i]+sliderLength[i]-1;
					if (mouseYchpos=sliderposY[i]) then
						begin
						if (mouseXchpos>=sliderposX[i] and mouseXchpos<=mx2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;				
				end;

			inc(i);
			end;
		end;


	case clickedSlider of
		0:  begin
			i:=sliderValue[0];
			YM2151::SetFB($20,i);
			SCF::DrawHexByte(10,30,i,4);
			end;
		1:	begin
			i:=sliderValue[1];
			SCF::DrawHexByte(10,52,i,5);
			end;
		end;
	end;

procedure handlemouse();
	begin
	X16Mouse::GetState();	
	
	SCF::DrawHexByte(75,56,X16Mouse::Buttons,1);
	SCF::DrawHexInt(70,57,X16Mouse::X,4);
	SCF::DrawHexInt(70,58,X16Mouse::Y,5);
	mouseXchpos:=X16Mouse::X>>3;
	mouseYchpos:=X16Mouse::Y>>3;
	SCF::DrawHexByte(75,57,mouseXchpos,4);
	SCF::DrawHexByte(75,58,mouseYchpos,5);
	

	if (X16Mouse::Buttons=1) then 
		begin
		handlesliderclick();
		if mouseClicked=0 then
			begin
			mouseXchposAtClick:=mouseXchpos;
			mouseYchposAtClick:=mouseYchpos;
			mouseClicked:=1;
			end;
		end;
	if (X16Mouse::Buttons=0) then 
		begin
			if mouseClicked=1 then
			begin
			handlebuttonclick();
			mouseClicked:=0;
			end;
		end;
	end;

procedure drawButton(butt:byte);
	var labelx,labely:byte;
	begin
	SCF::DrawBox(buttonposX[butt],buttonposY[butt],buttonWidth[butt],buttonHeight[butt],buttonColor[butt]);
	labelx:=buttonposX[butt]+buttonWidth[butt]>>1;
	labely:=buttonposY[butt]+buttonHeight[butt]>>1;
	SCF::DrawChar(labelx,labely,buttonLabel[butt],buttonColor[butt]);
	//for x:=buttonposX[butt] to buttonposX[butt]+buttonWidth[butt] do
	//	for y:=buttonposY[butt] to buttonposY[butt]+buttonHeight[butt] do
	//		DrawChar(x,y,@Space,buttonColor[butt]);
	end;

procedure drawButtons();
	var i:byte;
	begin
	for i:=0 to @ButtonCount do drawButton(i);
	end;

procedure drawSliders();
	var i:byte;
	begin
	for i:=0 to @SliderCount do drawSlider(i);
	end;


//MAIN START

begin
YM2151::Reset();
X16Mouse::CursorOn();

SCF::InitScreen(0);
SCF::DrawLabel(0,0,"SYNTHUI",1);

drawButtons();
drawSliders();


YM2151::SetReg($20,%11000111);//RLFFFBBB     Right Left Feedback Connect
YM2151::SetReg($60,21);//0TTTTTTT			Total level (reversed 0 max, 127 min)
YM2151::SetReg($80,31);//KK0AAAAA			KS    AR			(Key Scaling, Attack)
YM2151::SetReg($A0,0);//A00DDDDD			AMS-EN      D1R		(Amplitude modulation, Decay1)
YM2151::SetReg($C0,0);//TT0DDDDD			DT2    		D2R 	(Useless Detune, Decay2
YM2151::SetReg($E0,5);//DDDDRRRR			D1L			RR		(Sustain, Release)

	
key:=$0;	
while (key<>3) do
	begin
	getin();
	if (key<>0) then 
		begin	
		if (key=$20) then YM2151::SetReg($08,%00000000) //Keyoff simulation with space
		else
			begin
			SCF::DrawHexByte(75, 55,  key, 5);
			key2note();
			if(note<>$FF) then
				begin
				toYMoctavenote();
				YM2151::SetReg($28,ymoctavenote);
				YM2151::SetReg($08,%01111000);
				end;
			end;
		end;

	handlemouse();

	SCF::DrawHexByte(2,59,transpose,7);
	end;

X16Mouse::CursorOff();
YM2151::Reset();
return();
end.
 