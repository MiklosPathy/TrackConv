program SynthUI;

@use "SimpleCharFunctions"
@use "YM2151"
@use "X16Mouse"
@use "Input"


var
    WidgetMap: array[4800] of byte;

	transpose:byte=3;

	mouseXchpos: byte;
	mouseYchpos: byte;
	
	slres:byte;
	
	mouseXchposAtClick: byte;
	mouseYchposAtClick: byte;
	mouseClicked:byte;
	
	tButton = record
		posX, posY, Width, Height, Color, Label : byte;
	end;


    @define ButtonCount 2
	buttons:array[@ButtonCount] of tButton;
	
	tSlider = record
		posX, posY, Length_, Color, Value, Max_, Mode, AttachedLabel : byte;	
	end;

	@define Vertical 0
	@define Horizontal 1
	@define SliderCount 4

	sliders:array[@SliderCount] of tSlider;

	clickedSlider:byte=$FF;

	tLabel = record
		posX, posY, Value, Color : byte;	
	end;
	@define LabelCount 4
	labels:array[@LabelCount] of tSlider;

procedure PlaceOnWidgetMap(posX,posY,Width,Height,WID:byte);
var x,y:byte;
	i:integer;
	begin
	for y:=posY to posY+Height do
		begin
		i:=y*80;
		for x:=posX to posX+Width do
			WidgetMap[i+x]:=WID;
		end;
	end;

procedure drawLabel(lbl:byte);
	begin
	SCF::DrawHexByte(labels[lbl].posX,labels[lbl].posY,labels[lbl].Value,labels[lbl].Color);
	end;

procedure setLabelValue(lbl,value:byte);
	begin
	labels[lbl].Value:=value;
	drawLabel(lbl);
	end;

procedure handlebuttonclick();
	var clickedButton:byte;
	begin
	clickedButton:=WidgetMap[(mouseYchposAtClick*80)+mouseXchposAtClick];

		case clickedButton of
		0: dec(transpose);
		1: inc(transpose);
		end;

	end;

procedure getSlidePosition(sllen,slval,slmax,slpos:byte);
	var temp:integer;
	begin
	if (sllen-1=slmax) then	slres:=slpos+slval
	else
		begin
		temp:=sllen*slval/slmax;
		slres:=temp+slpos;
		if slres>slpos+sllen-1 then slres:=slpos+sllen-1;
		end;
	end;

procedure getSliderValue(mousepos,sllen,slmax,slpos:byte);
	var temp,relpos:integer;
		rpb:byte;
	begin
	if (sllen-1=slmax) then	slres:=mousepos-slpos
	else
		begin
		temp:=0;
		rpb:=sllen/slmax/2;
		rpb:=mousepos-slpos+rpb;
		relpos:=rpb;
		temp:=relpos*slmax;
		temp:=temp/sllen;
		slres:=temp;	
		end;
	end;

procedure drawSlider(slid:byte);
	var i:byte;
	begin
	case sliders[slid].Mode of
		@Vertical:
			begin	
			for i:=sliders[slid].posY to sliders[slid].posY+sliders[slid].Length_ do
				SCF::DrawChar(sliders[slid].posX,i,$5D,sliders[slid].Color);

			getSlidePosition(sliders[slid].Length_,sliders[slid].Value,sliders[slid].Max_,sliders[slid].posY);
			SCF::DrawChar(sliders[slid].posX,slres,$5B,sliders[slid].Color);
			end;
		@Horizontal:
			begin
			for i:=sliders[slid].posX to sliders[slid].posX+sliders[slid].Length_ do
				SCF::DrawChar(i,sliders[slid].posY,$43,sliders[slid].Color);
			
			getSlidePosition(sliders[slid].Length_,sliders[slid].Value,sliders[slid].Max_,sliders[slid].posX);
			SCF::DrawChar(slres,sliders[slid].posY,$5B,sliders[slid].Color);
			end;
		end;
	if (sliders[slid].AttachedLabel<>$FF) then setLabelValue(sliders[slid].AttachedLabel,sliders[slid].Value);

	end;

procedure calcSliderpos(slid:byte);
	begin
	case sliders[slid].Mode of
		@Vertical:
			begin
			getSliderValue(mouseYchpos,sliders[slid].Length_,sliders[slid].Max_,sliders[slid].posY);	
			sliders[slid].Value:=slres;
			end;
		@Horizontal:
			begin	
			getSliderValue(mouseXchpos,sliders[slid].Length_,sliders[slid].Max_,sliders[slid].posX);	
			sliders[slid].Value:=slres;
			end;
		end;						
	end;

procedure handlesliderclick();
	var i,mx2,my2:byte;
	begin

	if (mouseClicked=1 and clickedSlider<>$FF) then
		case sliders[clickedSlider].Mode of
			@Vertical:
				begin
				my2:=sliders[clickedSlider].posY+sliders[clickedSlider].Length_-1;
				if (mouseYchpos>=sliders[clickedSlider].posY and mouseYchpos<=my2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			@Horizontal:
				begin
				mx2:=sliders[clickedSlider].posX+sliders[clickedSlider].Length_-1;
				if (mouseXchpos>=sliders[clickedSlider].posX and mouseXchpos<=mx2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			end
	else
		begin
		i:=0;
		clickedSlider:=$FF;

		while (i<@SliderCount and clickedSlider=$FF) do
			begin;
			case sliders[i].Mode of
				@Vertical:
					begin			
					my2:=sliders[i].posY+sliders[i].Length_-1;
					if (mouseXchpos=sliders[i].posX) then
						begin
						if (mouseYchpos>=sliders[i].posY and mouseYchpos<=my2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;
				@Horizontal:
					begin
					mx2:=sliders[i].posX+sliders[i].Length_-1;
					if (mouseYchpos=sliders[i].posY) then
						begin
						if (mouseXchpos>=sliders[i].posX and mouseXchpos<=mx2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;				
				end;

			inc(i);
			end;
		end;


	case clickedSlider of
		0:  begin
			i:=sliders[0].Value;
			YM2151::SetFB($20,i);
			end;
		1:	begin
			i:=sliders[1].Value;
			end;
		end;
	end;

procedure handlemouse();
	begin
	X16Mouse::GetState();	
	
	SCF::DrawHexByte(75,56,X16Mouse::Buttons,1);
	SCF::DrawHexInt(70,57,X16Mouse::X,4);
	SCF::DrawHexInt(70,58,X16Mouse::Y,5);
	mouseXchpos:=X16Mouse::X>>3;
	mouseYchpos:=X16Mouse::Y>>3;
	SCF::DrawHexByte(75,57,mouseXchpos,4);
	SCF::DrawHexByte(75,58,mouseYchpos,5);
	

	if (X16Mouse::Buttons=1) then 
		begin
		handlesliderclick();
		if mouseClicked=0 then
			begin
			mouseXchposAtClick:=mouseXchpos;
			mouseYchposAtClick:=mouseYchpos;
			mouseClicked:=1;
			end;
		end;
	if (X16Mouse::Buttons=0) then 
		begin
			if mouseClicked=1 then
			begin
			handlebuttonclick();
			mouseClicked:=0;
			end;
		end;
	end;

procedure drawButton(butt:byte);
	var labelx,labely:byte;
	begin
	SCF::DrawBox(buttons[butt].posX,buttons[butt].posY,buttons[butt].Width,buttons[butt].Height,buttons[butt].Color);
	labelx:=buttons[butt].posX+buttons[butt].Width>>1;
	labely:=buttons[butt].posY+buttons[butt].Height>>1;
	SCF::DrawChar(labelx,labely,buttons[butt].Label,buttons[butt].Color);
	butt:=butt&%00111111; //Buttons are 00
	PlaceOnWidgetMap(buttons[butt].posX,buttons[butt].posY,buttons[butt].Width,buttons[butt].Height,butt);
	end;

procedure drawButtons();
	var i:byte;
	begin
	for i:=0 to @ButtonCount do drawButton(i);
	end;

procedure drawSliders();
	var i:byte;
	begin
	for i:=0 to @SliderCount do drawSlider(i);
	end;
	
procedure drawLabels();
	var i:byte;
	begin
	for i:=0 to @LabelCount do drawLabel(i);
	end;

procedure createButtons();
	begin
	buttons[0].posX:=10;
	buttons[0].posY:=10;
	buttons[0].Width:=3;
	buttons[0].Height:=3;
	buttons[0].Color:=8;
	buttons[0].Label:=45;

	buttons[1].posX:=15;
	buttons[1].posY:=10;
	buttons[1].Width:=3;
	buttons[1].Height:=3;
	buttons[1].Color:=9;
	buttons[1].Label:=43;
	end;

procedure createSliders();
	begin
	SCF::TextAtPos(10,18,"FEEDBACK",4);		

	sliders[0].posX:=10;
	sliders[0].posY:=20;
	sliders[0].Length_:=8;
	sliders[0].Color:=4;
	sliders[0].Value:=0;
	sliders[0].Max_:=7;
	sliders[0].Mode:=@Vertical;
	sliders[0].AttachedLabel:=0;
	
	labels[0].posX:=10;
	labels[0].posY:=29;
	labels[0].Value:=sliders[0].Value;
	labels[0].Color:=4;


	sliders[1].posX:=10;
	sliders[1].posY:=40;
	sliders[1].Length_:=10;
	sliders[1].Color:=5;
	sliders[1].Value:=1;
	sliders[1].Max_:=2;
	sliders[1].Mode:=@Horizontal;	
	sliders[1].AttachedLabel:=1;

	labels[1].posX:=6;
	labels[1].posY:=40;
	labels[1].Value:=sliders[1].Value;
	labels[1].Color:=sliders[1].Color;
	

	sliders[2].posX:=10;
	sliders[2].posY:=45;
	sliders[2].Length_:=10;
	sliders[2].Color:=6;
	sliders[2].Value:=1;
	sliders[2].Max_:=9;
	sliders[2].Mode:=@Horizontal;	
	sliders[2].AttachedLabel:=2;

	labels[2].posX:=6;
	labels[2].posY:=45;
	labels[2].Value:=sliders[2].Value;
	labels[2].Color:=sliders[2].Color;


	sliders[3].posX:=10;
	sliders[3].posY:=50;
	sliders[3].Length_:=10;
	sliders[3].Color:=7;
	sliders[3].Value:=0;
	sliders[3].Max_:=30;
	sliders[3].Mode:=@Horizontal;	
	sliders[3].AttachedLabel:=3;
	
	labels[3].posX:=6;
	labels[3].posY:=50;
	labels[3].Value:=sliders[3].Value;
	labels[3].Color:=sliders[3].Color;
	end;

procedure ClearWidgetMap();
var i:integer;
	begin
	for i:=0 to 4799 do WidgetMap[i]:=$FF;
	end;


//MAIN START

begin
YM2151::Reset();
X16Mouse::CursorOn();

SCF::InitScreen(0);
SCF::TextAtPos(0,0,"YM2151 SYNTH UI",1);

ClearWidgetMap();
createButtons();
drawButtons();
createSliders();
drawSliders();
drawLabels();

YM2151::SetReg($20,%11000111);	//RLFFFCCC		    Right Left Feedback Connect
YM2151::SetReg($60,21);			//0TTTTTTT			Total level (reversed 0 max, 127 min)
YM2151::SetReg($80,31);			//KK0AAAAA			KS    		AR			(Key Scaling, Attack)
YM2151::SetReg($A0,0);			//A00DDDDD			AMS-EN      D1R			(Amplitude modulation, Decay1)
YM2151::SetReg($C0,0);			//TT0DDDDD			DT2    		D2R 		(Useless Detune, Decay2
YM2151::SetReg($E0,5);			//DDDDRRRR			D1L			RR			(Sustain, Release)

	
Input::key:=$0;	
while (Input::key<>3) do
	begin
	Input::getin();
	if (Input::key<>0) then 
		begin	
		if (Input::key=$20) then YM2151::KeyOff() //Keyoff simulation with space
		else
			begin
			SCF::DrawHexByte(75, 55, Input::key, 5);
			Input::key2note();
			if(Input::note<>$FF) then
				begin
				YM2151::SetNote(Input::octave+transpose,Input::note); //Transpose
				YM2151::KeyOn();
				end;
			end;
		end;

	handlemouse();

	SCF::DrawHexByte(2,59,transpose,7);
	end;

X16Mouse::CursorOff();
YM2151::Reset();
return();
end.
 