program SynthUI;

@use "SimpleCharFunctions"
@use "YM2151"
@use "X16Mouse"
@use "Input"


var
    //WidgetMap: array[4800] of byte;

	transpose:byte=3;

	mouseXchpos: byte;
	mouseYchpos: byte;
	
	spres:byte;
	
	mouseXchposAtClick: byte;
	mouseYchposAtClick: byte;
	mouseClicked:byte;
	
    @define ButtonCount 2
	buttonposX:array[@ButtonCount] of byte = (10,15);
	buttonposY:array[@ButtonCount] of byte = (10,10);
	buttonWidth:array[@ButtonCount] of byte = (3,3);
	buttonHeight:array[@ButtonCount] of byte = (3,3);
	buttonColor:array[@ButtonCount] of byte = (8,9);
	buttonLabel:array[@ButtonCount] of byte = (45,43);
	
	@define Vertical 0
	@define Horizontal 1
	@define SliderCount 4
	sliderposX:array[@SliderCount] of byte = (10,10,10,10);
	sliderposY:array[@SliderCount] of byte = (20,40,45,50);
	sliderLength:array[@SliderCount] of byte = (8,10,10,10);
	sliderColor:array[@SliderCount] of byte = (4,5,6,7);
	sliderValue:array[@SliderCount] of byte = (0,1,1,0);
	sliderMax:array[@SliderCount] of byte = (7,2,9,30);
	sliderMode:array[@SliderCount] of byte = (@Vertical,@Horizontal,@Horizontal,@Horizontal);
	clickedSlider:byte=$FF;






procedure handlebuttonclick();
	var i,mx2,my2,clickedButton:byte;
	begin
	i:=0;
	clickedButton:=$FF;
	while (i<@ButtonCount and clickedButton=$FF) do
		begin;
		mx2:=buttonposX[i]+buttonWidth[i];
		my2:=buttonposY[i]+buttonHeight[i];
		if (mouseXchposAtClick>=buttonposX[i] and mouseXchposAtClick<=mx2) then  //Ouch... Only 2 parametern in and in if??? 
			if (mouseYchposAtClick>=buttonposY[i] and mouseYchposAtClick<=my2) then clickedButton:=i;
		inc(i);
		end;

	case clickedButton of
		0: dec(transpose);
		1: inc(transpose);
		end;

	end;

procedure getSlidePosition(splen,spval,spmax,sppos:byte);
	var temp:integer;
	begin
	if (splen-1>spmax) then
		begin
		temp:=splen*spval/spmax;
		spres:=temp+sppos;
		if spres>sppos+splen-1 then spres:=sppos+splen-1;
		end;
	if (splen-1=spmax) then
		begin
		spres:=sppos+spval;
		end;
	if (splen-1<spmax) then
		begin
		temp:=spmax*spval/splen;
		spres:=temp+sppos;
		if spres>sppos+splen-1 then spres:=sppos+splen-1;
		end;
	
	end;

procedure getSliderValue(mousepos,splen,spmax,sppos:byte);
	var temp,relpos:integer;
		rpb:byte;

	begin
	if (splen-1>spmax) then
		begin
		temp:=0;
		SCF::DrawHexByte(16,54,mousepos,1);
		SCF::DrawHexByte(22,54,sppos,1);
		SCF::DrawHexByte(16,55,splen,1);
		SCF::DrawHexByte(22,55,spmax,1);
		rpb:=splen/spmax/2;
		rpb:=mousepos-sppos+rpb;
		relpos:=rpb;
		SCF::DrawHexInt(16,52,relpos,1);
		temp:=relpos*spmax;
		SCF::DrawHexInt(22,52,temp,1);
		temp:=temp/splen;
		SCF::DrawHexInt(28,52,temp,1);
		spres:=temp;	
		end;
	if (splen-1=spmax) then
		begin
		spres:=mousepos-sppos;
		end;
	if (splen-1<spmax) then
		begin
		temp:=0;
		rpb:=mousepos-sppos;
		relpos:=rpb;
		temp:=relpos*spmax/splen;
		spres:=temp;	
		end;
	end;

procedure drawSlider(slid:byte);
	var i:byte;
	begin
	case sliderMode[slid] of
		@Vertical:
			begin	
			for i:=sliderposY[slid] to sliderposY[slid]+sliderLength[slid] do
				SCF::DrawChar(sliderposX[slid],i,$5D,sliderColor[slid]);
			SCF::DrawChar(sliderposX[slid],sliderposY[slid]+sliderValue[slid],$5B,sliderColor[slid]);
			end;
		@Horizontal:
			begin
			for i:=sliderposX[slid] to sliderposX[slid]+sliderLength[slid] do
				SCF::DrawChar(i,sliderposY[slid],$43,sliderColor[slid]);
				
			getSlidePosition(sliderLength[slid],sliderValue[slid],sliderMax[slid],sliderposX[slid]);
			SCF::DrawChar(spres,sliderposY[slid],$5B,sliderColor[slid]);
			end;
		end;
	end;

procedure calcSliderpos(slid:byte);
	begin
	case sliderMode[slid] of
		@Vertical:
			begin
			sliderValue[slid]:=mouseYchpos-sliderposY[slid];
			end;
		@Horizontal:
			begin	
			getSliderValue(mouseXchpos,sliderLength[slid],sliderMax[slid],sliderposX[slid]);	
			//sliderValue[slid]:=mouseXchpos-sliderposX[slid];
			sliderValue[slid]:=spres;
			end;
		end;						
	end;

procedure handlesliderclick();
	var i,mx2,my2:byte;
	begin

	if (mouseClicked=1 and clickedSlider<>$FF) then
		case sliderMode[clickedSlider] of
			@Vertical:
				begin
				my2:=sliderposY[clickedSlider]+sliderLength[clickedSlider]-1;
				if (mouseYchpos>=sliderposY[clickedSlider] and mouseYchpos<=my2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			@Horizontal:
				begin
				mx2:=sliderposX[clickedSlider]+sliderLength[clickedSlider]-1;
				if (mouseXchpos>=sliderposX[clickedSlider] and mouseXchpos<=mx2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			end
	else
		begin
		i:=0;
		clickedSlider:=$FF;

		while (i<@SliderCount and clickedSlider=$FF) do
			begin;
			case sliderMode[i] of
				@Vertical:
					begin			
					my2:=sliderposY[i]+sliderLength[i]-1;
					if (mouseXchpos=sliderposX[i]) then
						begin
						if (mouseYchpos>=sliderposY[i] and mouseYchpos<=my2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;
				@Horizontal:
					begin
					mx2:=sliderposX[i]+sliderLength[i]-1;
					if (mouseYchpos=sliderposY[i]) then
						begin
						if (mouseXchpos>=sliderposX[i] and mouseXchpos<=mx2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;				
				end;

			inc(i);
			end;
		end;


	case clickedSlider of
		0:  begin
			i:=sliderValue[0];
			YM2151::SetFB($20,i);
			SCF::DrawHexByte(10,30,i,4);
			end;
		1:	begin
			i:=sliderValue[1];
			SCF::DrawHexByte(10,52,i,5);
			end;
		end;
	end;

procedure handlemouse();
	begin
	X16Mouse::GetState();	
	
	SCF::DrawHexByte(75,56,X16Mouse::Buttons,1);
	SCF::DrawHexInt(70,57,X16Mouse::X,4);
	SCF::DrawHexInt(70,58,X16Mouse::Y,5);
	mouseXchpos:=X16Mouse::X>>3;
	mouseYchpos:=X16Mouse::Y>>3;
	SCF::DrawHexByte(75,57,mouseXchpos,4);
	SCF::DrawHexByte(75,58,mouseYchpos,5);
	

	if (X16Mouse::Buttons=1) then 
		begin
		handlesliderclick();
		if mouseClicked=0 then
			begin
			mouseXchposAtClick:=mouseXchpos;
			mouseYchposAtClick:=mouseYchpos;
			mouseClicked:=1;
			end;
		end;
	if (X16Mouse::Buttons=0) then 
		begin
			if mouseClicked=1 then
			begin
			handlebuttonclick();
			mouseClicked:=0;
			end;
		end;
	end;

procedure drawButton(butt:byte);
	var labelx,labely:byte;
	begin
	SCF::DrawBox(buttonposX[butt],buttonposY[butt],buttonWidth[butt],buttonHeight[butt],buttonColor[butt]);
	labelx:=buttonposX[butt]+buttonWidth[butt]>>1;
	labely:=buttonposY[butt]+buttonHeight[butt]>>1;
	SCF::DrawChar(labelx,labely,buttonLabel[butt],buttonColor[butt]);
	//for x:=buttonposX[butt] to buttonposX[butt]+buttonWidth[butt] do
	//	for y:=buttonposY[butt] to buttonposY[butt]+buttonHeight[butt] do
	//		DrawChar(x,y,@Space,buttonColor[butt]);
	end;

procedure drawButtons();
	var i:byte;
	begin
	for i:=0 to @ButtonCount do drawButton(i);
	end;

procedure drawSliders();
	var i:byte;
	begin
	for i:=0 to @SliderCount do drawSlider(i);
	end;


//MAIN START

begin
YM2151::Reset();
X16Mouse::CursorOn();

SCF::InitScreen(0);
SCF::DrawLabel(0,0,"SYNTHUI",1);

SCF::DrawLabel(27,52,"Q",1);

drawButtons();
drawSliders();


YM2151::SetReg($20,%11000111);	//RLFFFCCC		    Right Left Feedback Connect
YM2151::SetReg($60,21);			//0TTTTTTT			Total level (reversed 0 max, 127 min)
YM2151::SetReg($80,31);			//KK0AAAAA			KS    		AR			(Key Scaling, Attack)
YM2151::SetReg($A0,0);			//A00DDDDD			AMS-EN      D1R			(Amplitude modulation, Decay1)
YM2151::SetReg($C0,0);			//TT0DDDDD			DT2    		D2R 		(Useless Detune, Decay2
YM2151::SetReg($E0,5);			//DDDDRRRR			D1L			RR			(Sustain, Release)

	
Input::key:=$0;	
while (Input::key<>3) do
	begin
	Input::getin();
	if (Input::key<>0) then 
		begin	
		if (Input::key=$20) then YM2151::KeyOff() //Keyoff simulation with space
		else
			begin
			SCF::DrawHexByte(75, 55, Input::key, 5);
			Input::key2note();
			if(Input::note<>$FF) then
				begin
				YM2151::SetNote(Input::octave+transpose,Input::note); //Transpose
				YM2151::KeyOn();
				end;
			end;
		end;

	handlemouse();

	SCF::DrawHexByte(2,59,transpose,7);
	end;

X16Mouse::CursorOff();
YM2151::Reset();
return();
end.
 