program SynthUI;

@use "SimpleCharFunctions"
@use "YM2151"
@use "X16Mouse"
@use "Input"

@define WidgetMapSize 4800
@define WidgetMaxCountByType 64

var
    WidgetMap: array[@WidgetMapSize] of byte;

	transpose:byte=3;

	mouseXchpos: byte;
	mouseYchpos: byte;

	mouseXchposAtClick: byte;
	mouseYchposAtClick: byte;
	mouseClicked:byte;
	
	tButton = record
		posX, posY, Width, Height, Color, Label : byte;
	end;

	buttons:array[@WidgetMaxCountByType] of tButton;
	
	tSlider = record
		posX, posY, Length_, Color, Value, Max_, Mode, AttachedLabel : byte;	
	end;

	@define Vertical 0
	@define Horizontal 1

	sliders:array[@WidgetMaxCountByType] of tSlider;

	clickedSlider:byte=$FF;

	tLabel = record
		posX, posY, Value, Color : byte;	
	end;

	labels:array[@WidgetMaxCountByType] of tLabel;

procedure putWidgetMapValue(posX,posY,value:byte);
var wmp:pointer;
	begin
	wmp:=WidgetMap[0];
	wmp:=wmp+(80*posY)+posX;
	wmp[0]:=value;
	end;

procedure getWidgetMapValue(posX,posY:byte);
var wmp:pointer;
	begin
	wmp:=WidgetMap[0];
	wmp:=wmp+(80*posY)+posX;
	ReturnValue(wmp[0]);
	end;

procedure ShowWidgetMap();
var x,y,v:byte;
	begin
	for y:=0 to 60 do
		for x:=0 to 80 do
			begin
			v:=getWidgetMapValue(x,y);
			SCF::DrawChar(x,y,v,1);
			end;
	end;

procedure ClearWidgetMap();
var	wmp,endpoint:pointer;
	begin
	wmp:=WidgetMap[0];
	endpoint:=wmp+@WidgetMapSize;
	while (wmp<endpoint) do
		begin
		wmp[0]:=$FF;
		inc(wmp);
		end;
	end;

procedure PlaceOnWidgetMap(posX,posY,Width,Height,WID:byte);
var x,y:byte;
	begin
	for y:=posY to posY+Height do
		for x:=posX to posX+Width do
			putWidgetMapValue(x,y,WID);
	end;

procedure drawLabel(lbl:byte);
	begin
	SCF::DrawHexByte(labels[lbl].posX,labels[lbl].posY,labels[lbl].Value,labels[lbl].Color);
	end;

procedure setLabelValue(lbl,value:byte);
	begin
	labels[lbl].Value:=value;
	drawLabel(lbl);
	end;

procedure handlebuttonclick();
	var clickedButton:byte;
	begin
	clickedButton:=getWidgetMapValue(mouseXchposAtClick,mouseYchposAtClick);
	if ((clickedButton>>6)=0) then
		begin
		case clickedButton of
		0: dec(transpose);
		1: inc(transpose);
		end;
		end;

	end;
	
procedure getSlidePositionFine(sllen,slval,slmax:byte);
	var temp:integer;
		slres:byte;
	begin
	if (sllen-1=slmax) then	slres:=slval
	else
		begin
		temp:=sllen*slval/slmax;
		slres:=temp;
		if slres>sllen-1 then slres:=sllen-1;
		end;
	returnvalue(slres);
	end;

procedure drawSlideHorizontalFine(slID:byte);
var slres,posx,chartype,char:byte;
	begin
	slres:=getSlidePositionFine(sliders[slID].Length_<<2,sliders[slID].Value,sliders[slID].Max_);
	posx:=(slres>>2)+sliders[slID].posX;
	chartype:=slres&%00000011;
	case chartype of
		0: char:=$74;
		1: char:=$47;
		2: char:=$48;
		3: char:=$6A;
		end;
	SCF::DrawChar(posx,sliders[slID].posY,char,sliders[slID].Color);	
	end;

procedure drawSlideVerticalFine(slID:byte);
var slres,posy,chartype,char:byte;
	begin
	slres:=getSlidePositionFine(sliders[slID].Length_<<2,sliders[slID].Value,sliders[slID].Max_);
	posy:=(slres>>2)+sliders[slID].posY;
	chartype:=slres&%00000011;
	case chartype of
		0: char:=$77;
		1: char:=$44;
		2: char:=$46;
		3: char:=$6F;
		end;
	SCF::DrawChar(sliders[slID].posX,posy,char,sliders[slID].Color);
	end;

procedure getSliderValueFine(mousepos:integer;mousechpos,slpos,sllen,slmax:byte);
var mousecorrected,sliderposcorrected,temp:integer;
	endcharpos,slres:byte;
	begin
	if (mousechpos<slpos) then ReturnValue(0);
	endcharpos:=slpos+sllen-1;
	if (endcharpos<mousechpos) then ReturnValue(slmax);
	sliderposcorrected:=slpos;
	sliderposcorrected:=sliderposcorrected<<2;
	mousecorrected:=(mousepos>>1)-sliderposcorrected;
	temp:=slmax*mousecorrected/(sllen<<2);
	slres:=temp;	
	returnvalue(slres);
	end;

procedure drawSlider(slid:byte);
	var i:byte;
	begin
	case sliders[slid].Mode of
		@Vertical:
			begin	
			for i:=sliders[slid].posY to sliders[slid].posY+sliders[slid].Length_ do
				SCF::DrawChar(sliders[slid].posX,i,$5D,sliders[slid].Color);

			drawSlideVerticalFine(slid)
//			slres:=getSlidePosition(sliders[slid].Length_,sliders[slid].Value,sliders[slid].Max_,sliders[slid].posY);
//			SCF::DrawChar(sliders[slid].posX,slres,$5B,sliders[slid].Color);
			end;
		@Horizontal:
			begin
			for i:=sliders[slid].posX to sliders[slid].posX+sliders[slid].Length_ do
				SCF::DrawChar(i,sliders[slid].posY,$43,sliders[slid].Color);
			
			//drawSlideHorizontalChar(slid);
			drawSlideHorizontalFine(slid);
			end;
		end;
	if (sliders[slid].AttachedLabel<>$FF) then setLabelValue(sliders[slid].AttachedLabel,sliders[slid].Value);

	end;

procedure calcSliderValue(slID:byte);
	begin
	case sliders[slID].Mode of
		@Vertical:
			begin
			sliders[slID].Value:=getSliderValueFine(X16Mouse::Y,mouseYchpos,sliders[slID].posY,sliders[slID].Length_,sliders[slID].Max_);
			end;
		@Horizontal:
			begin	
			sliders[slID].Value:=getSliderValueFine(X16Mouse::X,mouseXchpos,sliders[slID].posX,sliders[slID].Length_,sliders[slID].Max_);
			end;
		end;						
	end;

procedure handlesliderclick();
	var slID,WID,WT:byte;
	begin
	if (mouseClicked=1 and clickedSlider<>$FF) then //Slider dragging.
		begin
		calcSliderValue(clickedSlider);
		drawSlider(clickedSlider);
		end
	else	
	begin
	clickedSlider:=$FF;
	WID:=getWidgetMapValue(mouseXchpos,mouseYchpos);
	WT:=WID&%11000000;
	if WT=%01000000 then //Slider
		begin
		slID:=WID&%00111111;
		clickedSlider:=slID;
		calcSliderValue(clickedSlider);
		drawSlider(clickedSlider);
		end;
	end;
	


	//SCF::DrawBinByte(40,6,clickedSlider,5);
		case clickedSlider of
			0:  begin
				slID:=sliders[0].Value;
				YM2151::SetFB($20,slID);
				end;
			1:	begin
				slID:=sliders[1].Value;
				end;
			end;

	end;

procedure handlemouse();
	begin
	X16Mouse::GetState();	
	
	SCF::DrawHexByte(75,56,X16Mouse::Buttons,1);
	SCF::DrawHexInt(70,57,X16Mouse::X,4);
	SCF::DrawHexInt(70,58,X16Mouse::Y,5);
	mouseXchpos:=X16Mouse::X>>3;
	mouseYchpos:=X16Mouse::Y>>3;
	SCF::DrawHexByte(75,57,mouseXchpos,4);
	SCF::DrawHexByte(75,58,mouseYchpos,5);
	SCF::DrawHexByte(75,59, getWidgetMapValue(mouseXchpos,mouseYchpos),7);

	if (X16Mouse::Buttons=1) then 
		begin
		handlesliderclick();
		if mouseClicked=0 then
			begin
			mouseXchposAtClick:=mouseXchpos;
			mouseYchposAtClick:=mouseYchpos;
			mouseClicked:=1;
			end;
		end;
	if (X16Mouse::Buttons=0) then 
		begin
			if mouseClicked=1 then
			begin
			handlebuttonclick();
			mouseClicked:=0;
			clickedSlider:=$FF;
			end;
		end;
	end;

procedure drawButton(butt:byte);
	var labelx,labely:byte;
	begin
	SCF::DrawBox(buttons[butt].posX,buttons[butt].posY,buttons[butt].Width,buttons[butt].Height,buttons[butt].Color);
	labelx:=buttons[butt].posX+buttons[butt].Width>>1;
	labely:=buttons[butt].posY+buttons[butt].Height>>1;
	SCF::DrawChar(labelx,labely,buttons[butt].Label,buttons[butt].Color);
	end;

procedure createButton(btID,posX,posY,Width,Height,Color,Label:byte);
var WID:byte;
	begin
	buttons[btID].posX:=posX;
	buttons[btID].posY:=posY;
	buttons[btID].Width:=Width;
	buttons[btID].Height:=Height;
	buttons[btID].Color:=Color;
	buttons[btID].Label:=Label;	
	WID:=btID&%00111111; //Bt type is 00;
	PlaceOnWidgetMap(posX,posY,Width,Height,WID);
	drawButton(btID);
	end;

procedure createSlider(slID,posX,posY,Length_,Color,Value,Max_,Mode,AttachedLabelID:byte);
var WID:byte;
	begin
	sliders[slID].posX:=posX;
	sliders[slID].posY:=posY;
	sliders[slID].Length_:=Length_;
	sliders[slID].Color:=Color;
	sliders[slID].Value:=Value;
	sliders[slID].Max_:=Max_;
	sliders[slID].Mode:=Mode;	
	sliders[slID].AttachedLabel:=AttachedLabelID;

	drawSlider(slID);

	WID:=slID|%01000000;
	case Mode of
		@Horizontal:PlaceOnWidgetMap(posX,posY,Length_,1,WID);
		@Vertical:PlaceOnWidgetMap(posX,posY,1,Length_,WID);
		end;

	end;
	
procedure createLabel(lbID,posX,posY,Value,Color:byte);
	begin
	labels[lbID].posX:=posX;
	labels[lbID].posY:=posY;
	labels[lbID].Value:=Value;
	labels[lbID].Color:=Color;
	drawLabel(lbID);
	//Label not Widget. No mouseclick. No Widgetmap
	end;

procedure createUI();
	begin
	SCF::TextAtPos(0,0,"YM2151 SYNTH UI",1);
	
	createButton(0,10,10,3,3,8,45);
	createButton(1,15,10,3,3,9,43);
	
	SCF::TextAtPos(10,18,"FEEDBACK",4);		
	createLabel(0,10,29,0,4);
	createSlider(0,10,20,8,4,0,7,@Vertical,0);
	
	createLabel(1,6,40,0,5);
	createSlider(1,10,40,10,5,1,2,@Horizontal,1);

	createLabel(2,6,45,0,6);
	createSlider(2,10,45,10,6,1,9,@Horizontal,2);

	createLabel(3,6,50,0,7);
	createSlider(3,10,50,10,7,0,$20,@Horizontal,3);
	end;


//MAIN START

begin
YM2151::Reset();
X16Mouse::CursorOn();

SCF::InitScreen(0);
ClearWidgetMap();
createUI();

//ShowWidgetMap();
//return();

YM2151::SetReg($20,%11000111);	//RLFFFCCC		    Right Left Feedback Connect
YM2151::SetReg($60,21);			//0TTTTTTT			Total level (reversed 0 max, 127 min)
YM2151::SetReg($80,31);			//KK0AAAAA			KS    		AR			(Key Scaling, Attack)
YM2151::SetReg($A0,0);			//A00DDDDD			AMS-EN      D1R			(Amplitude modulation, Decay1)
YM2151::SetReg($C0,0);			//TT0DDDDD			DT2    		D2R 		(Useless Detune, Decay2
YM2151::SetReg($E0,5);			//DDDDRRRR			D1L			RR			(Sustain, Release)

	
Input::key:=$0;	
while (Input::key<>3) do
	begin
	Input::getin();
	if (Input::key<>0) then 
		begin	
		if (Input::key=$20) then YM2151::KeyOff() //Keyoff simulation with space
		else
			begin
			SCF::DrawHexByte(75, 55, Input::key, 5);
			Input::key2note();
			if(Input::note<>$FF) then
				begin
				YM2151::SetNote(Input::octave+transpose,Input::note); //Transpose
				YM2151::KeyOn();
				end;
			end;
		end;

	handlemouse();

	SCF::DrawHexByte(2,59,transpose,7);
	end;

X16Mouse::CursorOff();
YM2151::Reset();
return();
end.
 