program SynthUI;

@use "SimpleCharFunctions"
@use "YM2151"
@use "X16Mouse"
@use "Input"


var
    //WidgetMap: array[4800] of byte;

	transpose:byte=3;

	mouseXchpos: byte;
	mouseYchpos: byte;
	
	spres:byte;
	
	mouseXchposAtClick: byte;
	mouseYchposAtClick: byte;
	mouseClicked:byte;
	
	tButton = record
		posX, posY, Width, Height, Color, Label : byte;
	end;


    @define ButtonCount 2
	buttons:array[@ButtonCount] of tButton;
	
	tSlider = record
		posX, posY, Length_, Color, Value, Max_, Mode : byte;	
	end;

	@define Vertical 0
	@define Horizontal 1
	@define SliderCount 4

	sliders:array[@SliderCount] of tSlider;

	clickedSlider:byte=$FF;






procedure handlebuttonclick();
	var i,mx2,my2,clickedButton:byte;
	begin
	i:=0;
	clickedButton:=$FF;
	while (i<@ButtonCount and clickedButton=$FF) do
		begin;
		mx2:=buttons[i].posX+buttons[i].Width;
		my2:=buttons[i].posY+buttons[i].Height;
		if (mouseXchposAtClick>=buttons[i].posX and mouseXchposAtClick<=mx2) then  //Ouch... Only 2 parametern in and in if??? 
			if (mouseYchposAtClick>=buttons[i].posY and mouseYchposAtClick<=my2) then clickedButton:=i;
		inc(i);
		end;

	case clickedButton of
		0: dec(transpose);
		1: inc(transpose);
		end;

	end;

procedure getSlidePosition(splen,spval,spmax,sppos:byte);
	var temp:integer;
	begin
	if (splen-1>spmax) then
		begin
		temp:=splen*spval/spmax;
		spres:=temp+sppos;
		if spres>sppos+splen-1 then spres:=sppos+splen-1;
		end;
	if (splen-1=spmax) then
		begin
		spres:=sppos+spval;
		end;
	if (splen-1<spmax) then
		begin
		temp:=spmax*spval/splen;
		spres:=temp+sppos;
		if spres>sppos+splen-1 then spres:=sppos+splen-1;
		end;
	
	end;

procedure getSliderValue(mousepos,splen,spmax,sppos:byte);
	var temp,relpos:integer;
		rpb:byte;

	begin
	if (splen-1>spmax) then
		begin
		temp:=0;
		SCF::DrawHexByte(16,54,mousepos,1);
		SCF::DrawHexByte(22,54,sppos,1);
		SCF::DrawHexByte(16,55,splen,1);
		SCF::DrawHexByte(22,55,spmax,1);
		rpb:=splen/spmax/2;
		rpb:=mousepos-sppos+rpb;
		relpos:=rpb;
		SCF::DrawHexInt(16,52,relpos,1);
		temp:=relpos*spmax;
		SCF::DrawHexInt(22,52,temp,1);
		temp:=temp/splen;
		SCF::DrawHexInt(28,52,temp,1);
		spres:=temp;	
		end;
	if (splen-1=spmax) then
		begin
		spres:=mousepos-sppos;
		end;
	if (splen-1<spmax) then
		begin
		temp:=0;
		rpb:=mousepos-sppos;
		relpos:=rpb;
		temp:=relpos*spmax/splen;
		spres:=temp;	
		end;
	end;

procedure drawSlider(slid:byte);
	var i:byte;
	begin
	case sliders[slid].Mode of
		@Vertical:
			begin	
			for i:=sliders[slid].posY to sliders[slid].posY+sliders[slid].Length_ do
				SCF::DrawChar(sliders[slid].posX,i,$5D,sliders[slid].Color);
			SCF::DrawChar(sliders[slid].posX,sliders[slid].posY+sliders[slid].Value,$5B,sliders[slid].Color);
			end;
		@Horizontal:
			begin
			for i:=sliders[slid].posX to sliders[slid].posX+sliders[slid].Length_ do
				SCF::DrawChar(i,sliders[slid].posY,$43,sliders[slid].Color);
				
			getSlidePosition(sliders[slid].Length_,sliders[slid].Value,sliders[slid].Max_,sliders[slid].posX);
			SCF::DrawChar(spres,sliders[slid].posY,$5B,sliders[slid].Color);
			end;
		end;
	end;

procedure calcSliderpos(slid:byte);
	begin
	case sliders[slid].Mode of
		@Vertical:
			begin
			sliders[slid].Value:=mouseYchpos-sliders[slid].posY;
			end;
		@Horizontal:
			begin	
			getSliderValue(mouseXchpos,sliders[slid].Length_,sliders[slid].Max_,sliders[slid].posX);	
			//sliderValue[slid]:=mouseXchpos-sliderposX[slid];
			sliders[slid].Value:=spres;
			end;
		end;						
	end;

procedure handlesliderclick();
	var i,mx2,my2:byte;
	begin

	if (mouseClicked=1 and clickedSlider<>$FF) then
		case sliders[clickedSlider].Mode of
			@Vertical:
				begin
				my2:=sliders[clickedSlider].posY+sliders[clickedSlider].Length_-1;
				if (mouseYchpos>=sliders[clickedSlider].posY and mouseYchpos<=my2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			@Horizontal:
				begin
				mx2:=sliders[clickedSlider].posX+sliders[clickedSlider].Length_-1;
				if (mouseXchpos>=sliders[clickedSlider].posX and mouseXchpos<=mx2) then 
					begin
					calcSliderpos(clickedSlider);
					drawSlider(clickedSlider);
					end;
				end;
			end
	else
		begin
		i:=0;
		clickedSlider:=$FF;

		while (i<@SliderCount and clickedSlider=$FF) do
			begin;
			case sliders[i].Mode of
				@Vertical:
					begin			
					my2:=sliders[i].posY+sliders[i].Length_-1;
					if (mouseXchpos=sliders[i].posX) then
						begin
						if (mouseYchpos>=sliders[i].posY and mouseYchpos<=my2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;
				@Horizontal:
					begin
					mx2:=sliders[i].posX+sliders[i].Length_-1;
					if (mouseYchpos=sliders[i].posY) then
						begin
						if (mouseXchpos>=sliders[i].posX and mouseXchpos<=mx2) then 
							begin
							clickedSlider:=i;
							calcSliderpos(i);
							drawSlider(i);
							end;
						end;
					end;				
				end;

			inc(i);
			end;
		end;


	case clickedSlider of
		0:  begin
			i:=sliders[0].Value;
			YM2151::SetFB($20,i);
			SCF::DrawHexByte(10,30,i,4);
			end;
		1:	begin
			i:=sliders[1].Value;
			SCF::DrawHexByte(10,52,i,5);
			end;
		end;
	end;

procedure handlemouse();
	begin
	X16Mouse::GetState();	
	
	SCF::DrawHexByte(75,56,X16Mouse::Buttons,1);
	SCF::DrawHexInt(70,57,X16Mouse::X,4);
	SCF::DrawHexInt(70,58,X16Mouse::Y,5);
	mouseXchpos:=X16Mouse::X>>3;
	mouseYchpos:=X16Mouse::Y>>3;
	SCF::DrawHexByte(75,57,mouseXchpos,4);
	SCF::DrawHexByte(75,58,mouseYchpos,5);
	

	if (X16Mouse::Buttons=1) then 
		begin
		handlesliderclick();
		if mouseClicked=0 then
			begin
			mouseXchposAtClick:=mouseXchpos;
			mouseYchposAtClick:=mouseYchpos;
			mouseClicked:=1;
			end;
		end;
	if (X16Mouse::Buttons=0) then 
		begin
			if mouseClicked=1 then
			begin
			handlebuttonclick();
			mouseClicked:=0;
			end;
		end;
	end;

procedure drawButton(butt:byte);
	var labelx,labely:byte;
	begin
	SCF::DrawBox(buttons[butt].posX,buttons[butt].posY,buttons[butt].Width,buttons[butt].Height,buttons[butt].Color);
	labelx:=buttons[butt].posX+buttons[butt].Width>>1;
	labely:=buttons[butt].posY+buttons[butt].Height>>1;
	SCF::DrawChar(labelx,labely,buttons[butt].Label,buttons[butt].Color);
	//for x:=buttonposX[butt] to buttonposX[butt]+buttonWidth[butt] do
	//	for y:=buttonposY[butt] to buttonposY[butt]+buttonHeight[butt] do
	//		DrawChar(x,y,@Space,buttonColor[butt]);
	end;

procedure drawButtons();
	var i:byte;
	begin
	for i:=0 to @ButtonCount do drawButton(i);
	end;

procedure drawSliders();
	var i:byte;
	begin
	for i:=0 to @SliderCount do drawSlider(i);
	end;

procedure createButtons();
	begin
	buttons[0].posX:=10;
	buttons[0].posY:=10;
	buttons[0].Width:=3;
	buttons[0].Height:=3;
	buttons[0].Color:=8;
	buttons[0].Label:=45;

	buttons[1].posX:=15;
	buttons[1].posY:=10;
	buttons[1].Width:=3;
	buttons[1].Height:=3;
	buttons[1].Color:=9;
	buttons[1].Label:=43;
	end;

procedure createSliders();
	begin
	sliders[0].posX:=10;
	sliders[0].posY:=20;
	sliders[0].Length_:=8;
	sliders[0].Color:=4;
	sliders[0].Value:=0;
	sliders[0].Max_:=7;
	sliders[0].Mode:=@Vertical;	

	sliders[1].posX:=10;
	sliders[1].posY:=40;
	sliders[1].Length_:=10;
	sliders[1].Color:=5;
	sliders[1].Value:=1;
	sliders[1].Max_:=2;
	sliders[1].Mode:=@Horizontal;	

	sliders[2].posX:=10;
	sliders[2].posY:=45;
	sliders[2].Length_:=10;
	sliders[2].Color:=6;
	sliders[2].Value:=1;
	sliders[2].Max_:=9;
	sliders[2].Mode:=@Horizontal;	

	sliders[3].posX:=10;
	sliders[3].posY:=50;
	sliders[3].Length_:=10;
	sliders[3].Color:=7;
	sliders[3].Value:=0;
	sliders[3].Max_:=30;
	sliders[3].Mode:=@Horizontal;	
	end;

//MAIN START

begin
YM2151::Reset();
X16Mouse::CursorOn();

SCF::InitScreen(0);
SCF::DrawLabel(0,0,"YM2151 SYNTH UI",1);

SCF::DrawLabel(27,52,"Q",1);

createButtons();
drawButtons();
createSliders();
drawSliders();


YM2151::SetReg($20,%11000111);	//RLFFFCCC		    Right Left Feedback Connect
YM2151::SetReg($60,21);			//0TTTTTTT			Total level (reversed 0 max, 127 min)
YM2151::SetReg($80,31);			//KK0AAAAA			KS    		AR			(Key Scaling, Attack)
YM2151::SetReg($A0,0);			//A00DDDDD			AMS-EN      D1R			(Amplitude modulation, Decay1)
YM2151::SetReg($C0,0);			//TT0DDDDD			DT2    		D2R 		(Useless Detune, Decay2
YM2151::SetReg($E0,5);			//DDDDRRRR			D1L			RR			(Sustain, Release)

	
Input::key:=$0;	
while (Input::key<>3) do
	begin
	Input::getin();
	if (Input::key<>0) then 
		begin	
		if (Input::key=$20) then YM2151::KeyOff() //Keyoff simulation with space
		else
			begin
			SCF::DrawHexByte(75, 55, Input::key, 5);
			Input::key2note();
			if(Input::note<>$FF) then
				begin
				YM2151::SetNote(Input::octave+transpose,Input::note); //Transpose
				YM2151::KeyOn();
				end;
			end;
		end;

	handlemouse();

	SCF::DrawHexByte(2,59,transpose,7);
	end;

X16Mouse::CursorOff();
YM2151::Reset();
return();
end.
 